#!/usr/bin/env python3
"""
Native Module Static Definition Generator

This tool automatically generates mpy_init functions for native modules that use
static module definitions, allowing them to use the same clean declaration pattern
as user C modules.

Usage:
    # Generate init function for a static module
    make_natmod_init.py module.c > natmod_init_gen.c

    # Extract module name for build system
    make_natmod_init.py --get-name module.c

Supported Patterns:
    The tool looks for modules that define:
    1. MP_REGISTER_MODULE(MP_QSTR_module_name, module_obj)
    2. A globals table named like 'module_name_globals_table[]'

    Example module structure:
        static const mp_rom_map_elem_t my_module_globals_table[] = {
            { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_my_module) },
            { MP_ROM_QSTR(MP_QSTR_function), MP_ROM_PTR(&function_obj) },
        };

        MP_REGISTER_MODULE(MP_QSTR_my_module, my_module);

Generated Output:
    Creates a simple mpy_init function that uses MP_DYNRUNTIME_INIT_STATIC_MODULE
    macro, which handles table iteration and size calculation automatically using
    MP_ARRAY_SIZE at compile time.

Error Handling:
    - Validates module and table names as valid C identifiers
    - Provides clear error messages for common issues
    - Fails gracefully when patterns aren't found
"""

import sys
import re
import argparse
import os


# Pattern to find MP_REGISTER_MODULE declarations
REGISTER_MODULE_PATTERN = re.compile(
    r"MP_REGISTER_MODULE\s*\(\s*MP_QSTR_(\w+)\s*,\s*(\w+)\s*\)",
    re.MULTILINE | re.DOTALL,
)


def find_module_registration(content):
    """Find MP_REGISTER_MODULE declaration in source content."""
    match = REGISTER_MODULE_PATTERN.search(content)
    if match:
        return match.group(1), match.group(2)  # module_name, module_obj
    return None, None


def validate_identifier(name):
    """Validate that a name is a valid C identifier."""
    if not name:
        return False
    if not re.match(r"^[a-zA-Z_][a-zA-Z0-9_]*$", name):
        return False
    return True


def find_globals_table_name(content, module_name):
    """Find the globals table name for a static module."""
    # Look for standard patterns (both mp_rom_map_elem_t and mp_rom_obj_t)
    patterns = [
        # Standard user C module pattern: module_globals_table
        rf"(?:static\s+)?const\s+mp_rom_map_elem_t\s+({module_name}_globals_table)\s*\[\s*\]\s*=",
        rf"(?:static\s+)?const\s+mp_rom_map_elem_t\s+({module_name}_module_globals_table)\s*\[\s*\]\s*=",
        # Native module pattern with mp_rom_obj_t (for key-value pairs)
        rf"(?:static\s+)?const\s+mp_rom_obj_t\s+({module_name}_globals_table)\s*\[\s*\]\s*=",
        rf"(?:static\s+)?const\s+mp_rom_obj_t\s+({module_name}_module_globals_table)\s*\[\s*\]\s*=",
        # Generic patterns
        r"(?:static\s+)?const\s+mp_rom_map_elem_t\s+(\w*globals_table)\s*\[\s*\]\s*=",
        r"(?:static\s+)?const\s+mp_rom_obj_t\s+(\w*globals_table)\s*\[\s*\]\s*=",
    ]

    for pattern in patterns:
        match = re.search(pattern, content)
        if match:
            return match.group(1)

    return None


def generate_mpy_init(module_name, globals_table):
    """Generate the mpy_init function for a static module."""
    return f'''// Auto-generated by make_natmod_init.py
// This file provides the mpy_init function for the '{module_name}' native module
// DO NOT EDIT - this file is regenerated automatically when source changes

#include "py/dynruntime.h"

// External reference to static globals table from source module
extern const mp_rom_map_elem_t {globals_table}[];

// Entry point called when the module is imported
mp_obj_t mpy_init(mp_obj_fun_bc_t *self, size_t n_args, size_t n_kw, mp_obj_t *args) {{
    // Initialize the module environment
    MP_DYNRUNTIME_INIT_ENTRY

    // Register all globals using the existing macro that handles
    // table iteration and MP_ARRAY_SIZE calculation automatically
    MP_DYNRUNTIME_INIT_STATIC_MODULE({globals_table});

    // Clean up and return
    MP_DYNRUNTIME_INIT_EXIT
}}

// Export module name for build system use
const char natmod_module_name[] = "{module_name}";
'''


def process_source_files(source_files, get_name_only=False):
    """Process source files to find static module definition."""
    for source_file in source_files:
        if not source_file.endswith(".c"):
            continue

        try:
            with open(source_file, "r", encoding="utf-8") as f:
                content = f.read()
        except (IOError, OSError) as e:
            print(f"Error reading {source_file}: {e}", file=sys.stderr)
            continue

        # Look for MP_REGISTER_MODULE
        module_name, module_obj = find_module_registration(content)
        if not module_name:
            continue

        # Validate module name
        if not validate_identifier(module_name):
            print(f"Error: Invalid module name '{module_name}' in {source_file}", file=sys.stderr)
            continue

        if get_name_only:
            # Just return the module name for build system
            return module_name

        # Find the globals table for this module
        globals_table = find_globals_table_name(content, module_name)
        if not globals_table:
            print(
                f"Error: Could not find globals table for module '{module_name}' in {source_file}",
                file=sys.stderr,
            )
            print(
                f"Expected a table named like '{module_name}_globals_table' or similar.",
                file=sys.stderr,
            )
            continue

        # Validate table name
        if not validate_identifier(globals_table):
            print(
                f"Error: Invalid globals table name '{globals_table}' in {source_file}",
                file=sys.stderr,
            )
            continue

        # Generate simple init function that uses MP_ARRAY_SIZE
        return generate_mpy_init(module_name, globals_table)

    return None


def main():
    parser = argparse.ArgumentParser(description="Generate mpy_init for static native modules")
    parser.add_argument(
        "source_files",
        nargs="+",
        help="Source files to process",
    )
    parser.add_argument(
        "--get-name",
        action="store_true",
        help="Just output the module name",
    )
    args = parser.parse_args()

    result = process_source_files(args.source_files, args.get_name)

    if result:
        print(result)
        return 0
    else:
        if not args.get_name:
            # No static module found, generate empty file
            print("// No static module definition found")
        return 1


if __name__ == "__main__":
    sys.exit(main())
