# py/make_deinit_function.py
"""
Generate mp_deinit_funcs.h from a collected list of deinit function registrations.

This script takes a file containing MP_REGISTER_DEINIT_FUNCTION(...) lines,
parses them, topologically sorts them based on dependencies, and generates
a C header file containing forward declarations and the mp_run_deinit_funcs()
function which calls the registered functions in the correct (reverse topological) order.
"""

from __future__ import print_function
import sys
import re
import os


def process_collected_file(input_filename):
    """Parses the collected file, sorts, and generates the C code."""

    # Read all items from the collected file
    try:
        with open(input_filename, "r", encoding='utf-8', errors='ignore') as f:
            all_items = f.read().splitlines()
            # Filter out empty lines
            all_items = [item for item in all_items if item.strip()]
    except Exception as e:
        print(f"Error reading input file {input_filename}: {e}", file=sys.stderr)
        print("Generating a minimal header file with no deinit functions", file=sys.stderr)
        # Return a valid but minimal header instead of exiting
        print("// Auto-generated by make_deinit_function.py - DO NOT EDIT")
        print("")
        print("#include \"py/obj.h\"")
        print("")
        print("// No valid registered deinit functions found.")
        print("")
        print("void mp_run_deinit_funcs(void) {")
        print("    // No deinit functions registered.")
        print("}")
        sys.exit(0)  # Exit with success

    # Sort for consistent processing order (although sort order doesn't affect final output)
    all_items.sort()

    # Parse function name, actual function, and dependency pairs
    # MP_REGISTER_DEINIT_FUNCTION(name, func) or MP_REGISTER_DEINIT_FUNCTION(name, func, dependency_name)
    # Handles formats with or without trailing semicolon
    regex_deinit = re.compile(
        r"MP_REGISTER_DEINIT_FUNCTION\s*\(([^,\s)]+)\s*,\s*([^,\s)]+)(?:\s*,\s*([^)]+))?\s*\);?"
    )
    deinit_funcs = []  # List of (name, func, dependency_name or None)
    malformed_lines = []
    missing_names = []

    for item in all_items:
        # Check if the item actually contains the macro call.
        if "MP_REGISTER_DEINIT_FUNCTION" in item:
            m = regex_deinit.search(item)  # Use search instead of match
            if m:
                name, func, dep = m.groups()
                # Basic validation for identifiers
                if not name or not name.isidentifier():
                    missing_names.append((name, item))
                    continue
                if not func or not func.isidentifier():
                    malformed_lines.append((f"Invalid function identifier '{func}'", item))
                    continue
                if dep and not dep.isidentifier():
                    malformed_lines.append((f"Invalid dependency identifier '{dep}'", item))
                    continue
                deinit_funcs.append((name, func, dep))  # Store tuple
            else:
                malformed_lines.append(("Malformed macro call", item))

    if missing_names:
        print("Warning: Found registrations with missing or invalid names:", file=sys.stderr)
        for name, line in missing_names:
            print(f"  Name '{name}' in: {line}", file=sys.stderr)

    if malformed_lines:
        print("Warning: Found malformed MP_REGISTER_DEINIT_FUNCTION lines:", file=sys.stderr)
        for reason, line in malformed_lines:
            print(f"  Reason: {reason} - Line: {line}", file=sys.stderr)

    # Custom topological sort implementation (adapted from makeqstrdefs.py)
    func_map = {name: (func, dep) for name, func, dep in deinit_funcs}
    sorted_funcs = []
    added = set()
    visiting = set()  # For cycle detection
    registered_names = set(func_map.keys())
    missing_deps_reported = set()

    def add_func(name):
        if name in added:
            return
        if name in visiting:
            print(
                f"Error: Circular dependency detected involving '{name}' in deinitialisation functions.",
                file=sys.stderr,
            )
            sys.exit(1)

        if name not in func_map:
            # This case means a dependency is listed but the function itself is not registered
            if name not in missing_deps_reported:
                print(
                    f"Warning: Deinitialisation function '{name}' is listed as a dependency but not registered itself.",
                    file=sys.stderr,
                )
                missing_deps_reported.add(name)
            # Treat the missing dependency as having no further dependencies itself
            # Add a placeholder to prevent repeated warnings and allow dependent functions to proceed
            added.add(name)
            return

        visiting.add(name)
        func, dep = func_map[name]

        if dep:
            add_func(dep)  # Recursively add the dependency first

        visiting.remove(name)
        added.add(name)
        # Append the original tuple (name, func, dep)
        sorted_funcs.append((name, func, dep))

    # Add all functions to the sorted list
    for name, _, _ in deinit_funcs:
        if name not in added:
            add_func(name)

    # Generate C code
    generated_code = [
        "// Auto-generated by make_deinit_function.py - DO NOT EDIT",
        "",
        "#include \"py/obj.h\"",
        "",
        "// Forward declarations",
    ]

    # Collect only valid, registered functions for declarations and calls
    valid_funcs_to_declare = [f for name, f, _ in sorted_funcs if name in registered_names]

    if not valid_funcs_to_declare:
        generated_code.append("// No valid registered deinit functions found.")
    else:
        declared = set()
        for func in valid_funcs_to_declare:
            if func not in declared:
                # Ensure valid C identifiers before generating declarations
                if func.isidentifier():
                    generated_code.append(f"void {func}(void);")
                    declared.add(func)
                else:
                    # Should have been caught earlier, but double-check
                    print(
                        f"Internal Error: Invalid identifier '{func}' reached declaration stage.",
                        file=sys.stderr,
                    )

    generated_code.append("\nvoid mp_run_deinit_funcs(void) {")

    if not valid_funcs_to_declare:
        generated_code.append(
            "    // No deinit functions registered or all had missing dependencies/were invalid.\n"
        )
    else:
        # Call functions in topologically sorted order (reversed for deinit)
        called_count = 0
        # Iterate through the *sorted* list in reverse for correct deinit order
        for name, func, dep in reversed(sorted_funcs):
            # Only call functions that were actually registered (present in func_map) and valid
            if name in func_map and func.isidentifier():
                dep_str = f" (depends on {dep})" if dep else ""
                generated_code.append(f"    // Deinit: {name}{dep_str}")
                generated_code.append(f"    {func}();")
                called_count += 1
        if called_count == 0:
            generated_code.append("    // No valid deinit functions to call.")

    generated_code.append("}")

    # Print the generated code to stdout
    print("\n".join(generated_code))


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("usage: %s <input_collected_file>" % sys.argv[0], file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    process_collected_file(input_file)
