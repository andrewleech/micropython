#!/usr/bin/env python

# Generate genhdr/moduledefs.h for inclusion in py/objmodule.c.

from __future__ import print_function

import re
import os
import sys
import json
import argparse
from glob import glob


def update_modules(vpath, object_files):
    pattern = re.compile(
        r"[\n;]\s*MP_REGISTER_MODULE\((.*?),\s*(.*?),\s*(.*?)\);",
        flags=re.DOTALL
    )

    modules = []
    for obj_file in object_files:
        c_file = None
        relative_c_file = os.path.splitext(obj_file)[0] + ".c"
        for p in vpath:
            possible_c_file = os.path.join(p, relative_c_file)
            if os.path.exists(possible_c_file):
                c_file = possible_c_file
                break

        if c_file is None:
            # No c file to match the object file, skip
            continue

        with open(c_file) as c_file_handle:
            c_text = c_file_handle.read()

        for mod in re.findall(pattern, c_text):
            # name, ref, guard = mod[0]
            modules.append(mod)
    
    # for module in sorted(os.listdir(path)):
    #     if not os.path.isfile('%s/%s/micropython.mk' % (path, module)):
    #         continue # not a module

    #     definition = '%s/%s/cmodule.json' % (path, module)
    #     if os.path.isfile(definition):
    #         with open(definition, 'r') as deffile:
    #             modules.update(json.load(deffile)['modules'])
    #     else:
    #         modules[module] = '%s_user_cmodule' % module

    # Print header file for all external modules.
    mod_defs = []
    print("// Automatically generated by makemoduledefs.py.\n")
    for name, ref, guard in modules:
        mod_def = "MODULE_DEF_{}".format(name.upper())
        mod_defs.append(mod_def)
        print((
            "#if {guard}\n"
            "    extern const struct _mp_obj_module_t {ref};\n"
            "    #define {mod_def} {{ MP_ROM_QSTR({name}), MP_ROM_PTR(&{ref}) }},\n"
            "#else\n"
            "    #define {mod_def}\n"
            "#endif\n"
            ).format(name=name, ref=ref, guard=guard, mod_def=mod_def)
        )

    print("\n#define MICROPY_REGISTERED_MODULES \\")

    for mod_def in mod_defs:
        print("    {{{mod_def}}} \\".format(mod_def=mod_def))

    print("// MICROPY_REGISTERED_MODULES")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--vpath", default=".", 
                        help="comma separated list of folders to search for c files in")
    parser.add_argument("files", nargs="*", help="list of object files matching c files to search") 
    args = parser.parse_args()

    vpath = [p.strip() for p in args.vpath.split(',')]

    update_modules(vpath, args.files)


if __name__ == '__main__':
    main()